pub trait FluxLimiter {
    /// Applies the limiter to two neighboring values.
    /// Returns a modified value that limits oscillations for TVD compliance.
    fn limit(&self, left_value: f64, right_value: f64) -> f64;
}

pub struct Minmod;
pub struct Superbee;

impl FluxLimiter for Minmod {
    fn limit(&self, left_value: f64, right_value: f64) -> f64 {
        if left_value * right_value <= 0.0 {
            println!("Minmod: Different signs or zero - returning 0.0");
            0.0 // Different signs, so we return zero to prevent oscillations
        } else {
            // Take the minimum of the absolute values with the correct sign
            let result = if left_value.abs() < right_value.abs() {
                left_value
            } else {
                right_value
            };
            println!("Minmod: left_value = {}, right_value = {}, result = {}", left_value, right_value, result);
            result
        }
    }
}

impl FluxLimiter for Superbee {
    fn limit(&self, left_value: f64, right_value: f64) -> f64 {
        if left_value * right_value <= 0.0 {
            println!("Superbee: Different signs or zero - returning 0.0");
            0.0 // Opposite signs: return zero to prevent oscillations
        } else {
            // Clamp the options to ensure they do not exceed the original values
            let option1 = (2.0 * left_value).clamp(left_value.min(right_value), left_value.max(right_value));
            let option2 = (2.0 * right_value).clamp(left_value.min(right_value), left_value.max(right_value));
            let result = option1.max(option2);

            println!(
                "Superbee: left_value = {}, right_value = {}, option1 = {}, option2 = {}, result = {}",
                left_value, right_value, option1, option2, result
            );

            result
        }
    }
}

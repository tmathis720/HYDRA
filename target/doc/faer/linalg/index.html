<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Linear algebra module."><title>faer::linalg - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="faer" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../faer/index.html">faer</a><span class="version">0.19.4</span></h2></div><h2 class="location"><a href="#">Module linalg</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In crate faer</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">faer</a>::<wbr><a class="mod" href="#">linalg</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/faer/linalg/mod.rs.html#1-171">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Linear algebra module.</p>
<p>Contains low level routines and the implementation of their corresponding high level
wrappers.</p>
<h2 id="memory-allocation"><a class="doc-anchor" href="#memory-allocation">§</a>Memory allocation</h2>
<p>Since most <code>faer</code> crates aim to expose a low level api for optimal performance, most algorithms
try to defer memory allocation to the user.</p>
<p>However, since a lot of algorithms need some form of temporary space for intermediate
computations, they may ask for a slice of memory for that purpose, by taking a <a href="../../dyn_stack/struct.PodStack.html" title="struct dyn_stack::PodStack"><code>stack: PodStack</code></a> parameter. A <a href="../../dyn_stack/struct.PodStack.html" title="struct dyn_stack::PodStack"><code>PodStack</code></a> is a thin wrapper over a slice of
memory bytes. This memory may come from any valid source (heap allocation, fixed-size array on
the stack, etc.). The functions taking a <a href="../../dyn_stack/struct.PodStack.html" title="struct dyn_stack::PodStack"><code>PodStack</code></a> parameter have a corresponding function
with a similar name ending in <code>_req</code> that returns the memory requirements of the algorithm. For
example:
<a href="householder/fn.apply_block_householder_on_the_left_in_place_with_conj.html" title="fn faer::linalg::householder::apply_block_householder_on_the_left_in_place_with_conj"><code>householder::apply_block_householder_on_the_left_in_place_with_conj</code></a> and
<a href="householder/fn.apply_block_householder_on_the_left_in_place_req.html" title="fn faer::linalg::householder::apply_block_householder_on_the_left_in_place_req"><code>householder::apply_block_householder_on_the_left_in_place_req</code></a>.</p>
<p>The memory stack may be reused in user-code to avoid repeated allocations, and it is also
possible to compute the sum (<a href="../../dyn_stack/stack_req/struct.StackReq.html#method.all_of" title="associated function dyn_stack::stack_req::StackReq::all_of"><code>dyn_stack::StackReq::all_of</code></a>) or union
(<a href="../../dyn_stack/stack_req/struct.StackReq.html#method.any_of" title="associated function dyn_stack::stack_req::StackReq::any_of"><code>dyn_stack::StackReq::any_of</code></a>) of multiple requirements, in order to optimally combine them
into a single allocation.</p>
<p>After computing a <a href="../../dyn_stack/stack_req/struct.StackReq.html" title="struct dyn_stack::stack_req::StackReq"><code>dyn_stack::StackReq</code></a>, one can query its size and alignment to allocate the
required memory. The simplest way to do so is through <a href="../../dyn_stack/mem/struct.GlobalMemBuffer.html#method.new" title="associated function dyn_stack::mem::GlobalMemBuffer::new"><code>dyn_stack::GlobalMemBuffer::new</code></a>.</p>
<h2 id="entity-trait"><a class="doc-anchor" href="#entity-trait">§</a>Entity trait</h2>
<p>Matrices are built on top of the <a href="../trait.Entity.html" title="trait faer::Entity"><code>Entity</code></a> trait, which describes the preferred memory
storage layout for a given type <code>E</code>. An entity can be decomposed into a group of units: for
a natively supported type (<a href="https://doc.rust-lang.org/1.80.1/std/primitive.f32.html" title="primitive f32"><code>f32</code></a>, <a href="https://doc.rust-lang.org/1.80.1/std/primitive.f64.html" title="primitive f64"><code>f64</code></a>, <a href="../complex_native/struct.c32.html" title="struct faer::complex_native::c32"><code>c32</code></a>,
<a href="../complex_native/struct.c64.html" title="struct faer::complex_native::c64"><code>c64</code></a>), the unit is simply the type itself, and a group
contains a single element. On the other hand, for a type with a more specific preferred
layout, like an extended precision floating point type, or a dual number type, the unit
would be one of the natively supported types, and the group would be a structure holding
the components that build up the full value.</p>
<p>To take a more specific example: <a href="../../num_complex/struct.Complex.html" title="struct num_complex::Complex"><code>num_complex::Complex&lt;f64&gt;</code></a> has a storage memory layout
that differs from that of <a href="../complex_native/struct.c64.html" title="struct faer::complex_native::c64"><code>c64</code></a> (see
<a href="../complex_native/index.html" title="mod faer::complex_native"><code>faer::complex_native</code></a> for more details). Its real and complex
components are stored separately, so its unit type is <code>f64</code>, while its group type is
<code>Complex</code>. In practice, this means that for a <code>Mat&lt;f64&gt;</code>, methods such as
<a href="../mat/struct.Mat.html#method.col_as_slice" title="method faer::mat::Mat::col_as_slice"><code>Mat::col_as_slice</code></a> will return a <code>&amp;[f64]</code>. Meanwhile, for a <code>Mat&lt;Complex&lt;f64&gt;&gt;</code>,
<a href="../mat/struct.Mat.html#method.col_as_slice" title="method faer::mat::Mat::col_as_slice"><code>Mat::col_as_slice</code></a> will return <code>Complex&lt;&amp;[f64]&gt;</code>, which holds two slices, each pointing
respectively to a view over the real and the imaginary components.</p>
<p>While the design of the entity trait is unconventional, it helps us achieve much higher
performance when targeting non native types, due to the design matching the typical
preferred CPU layout for SIMD operations. And for native types, since <a href="../trait.Entity.html#impl-Entity-for-f64" title="trait faer::Entity"><code>Group&lt;T&gt;</code> is just
<code>T</code></a>, the entity layer is a no-op, and the matrix layout is
compatible with the classic contiguous layout that’s commonly used by other libraries.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.entity"><code>pub use <a class="mod" href="../../faer_entity/index.html" title="mod faer_entity">faer_entity</a> as entity;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="cholesky/index.html" title="mod faer::linalg::cholesky">cholesky</a></div><div class="desc docblock-short">Low level implementation of the various Cholesky-like decompositions.</div></li><li><div class="item-name"><a class="mod" href="evd/index.html" title="mod faer::linalg::evd">evd</a></div><div class="desc docblock-short">Low level implementation of the eigenvalue decomposition of a square diagonalizable matrix.</div></li><li><div class="item-name"><a class="mod" href="householder/index.html" title="mod faer::linalg::householder">householder</a></div><div class="desc docblock-short">Block Householder transformations.</div></li><li><div class="item-name"><a class="mod" href="lu/index.html" title="mod faer::linalg::lu">lu</a></div><div class="desc docblock-short">Low level implementation of the LU decompositions.</div></li><li><div class="item-name"><a class="mod" href="matmul/index.html" title="mod faer::linalg::matmul">matmul</a></div><div class="desc docblock-short">Matrix multiplication.</div></li><li><div class="item-name"><a class="mod" href="qr/index.html" title="mod faer::linalg::qr">qr</a></div><div class="desc docblock-short">This crate provides utilities for computing and manipulating the QR factorization with and
without pivoting. The QR factorization decomposes a matrix into a product of a unitary matrix
$Q$ (represented using block Householder sequences), and an upper trapezoidal matrix $R$, such
that their product is equal to the original matrix (or a column permutation of it in the case
where column pivoting is used).</div></li><li><div class="item-name"><a class="mod" href="solvers/index.html" title="mod faer::linalg::solvers">solvers</a></div><div class="desc docblock-short">High level linear system solvers.</div></li><li><div class="item-name"><a class="mod" href="svd/index.html" title="mod faer::linalg::svd">svd</a></div><div class="desc docblock-short">Low level implementation of the SVD of a matrix.</div></li><li><div class="item-name"><a class="mod" href="triangular_inverse/index.html" title="mod faer::linalg::triangular_inverse">triangular_inverse</a></div><div class="desc docblock-short">Triangular matrix inversion.</div></li><li><div class="item-name"><a class="mod" href="triangular_solve/index.html" title="mod faer::linalg::triangular_solve">triangular_solve</a></div><div class="desc docblock-short">Triangular solve module.</div></li><li><div class="item-name"><a class="mod" href="zip/index.html" title="mod faer::linalg::zip">zip</a></div><div class="desc docblock-short">Implementation of <a href="../prelude/macro.zipped.html" title="macro faer::prelude::zipped"><code>zipped!</code></a> structures.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.kron.html" title="fn faer::linalg::kron">kron</a></div><div class="desc docblock-short">Kronecker product of two matrices.</div></li><li><div class="item-name"><a class="fn" href="fn.temp_mat_constant.html" title="fn faer::linalg::temp_mat_constant">temp_mat_constant</a></div><div class="desc docblock-short">Creates a temporary matrix of constant values, from the given memory stack.</div></li><li><div class="item-name"><a class="fn" href="fn.temp_mat_req.html" title="fn faer::linalg::temp_mat_req">temp_mat_req</a></div><div class="desc docblock-short">Returns the stack requirements for creating a temporary matrix with the given dimensions.</div></li><li><div class="item-name"><a class="fn" href="fn.temp_mat_uninit.html" title="fn faer::linalg::temp_mat_uninit">temp_mat_uninit</a></div><div class="desc docblock-short">Creates a temporary matrix of untouched values, from the given memory stack.</div></li><li><div class="item-name"><a class="fn" href="fn.temp_mat_zeroed.html" title="fn faer::linalg::temp_mat_zeroed">temp_mat_zeroed</a></div><div class="desc docblock-short">Creates a temporary matrix of zero values, from the given memory stack.</div></li></ul></section></div></main></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`faer` is a general-purpose linear algebra library for Rust, with a focus on high performance for algebraic operations on medium/large matrices, as well as matrix decompositions."><title>faer - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="faer" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../faer/index.html">faer</a><span class="version">0.19.4</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">faer</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/faer/lib.rs.html#1-1789">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>faer</code> is a general-purpose linear algebra library for Rust, with a focus on high performance
for algebraic operations on medium/large matrices, as well as matrix decompositions.</p>
<p>Most of the high-level functionality in this library is provided through associated functions in
its vocabulary types: <a href="mat/struct.Mat.html" title="struct faer::mat::Mat"><code>Mat</code></a>/<a href="mat/struct.MatRef.html" title="struct faer::mat::MatRef"><code>MatRef</code></a>/<a href="mat/struct.MatMut.html" title="struct faer::mat::MatMut"><code>MatMut</code></a>.</p>
<p><code>faer</code> is recommended for applications that handle medium to large dense matrices, and its
design is not well suited for applications that operate mostly on low dimensional vectors and
matrices such as computer graphics or game development. For those purposes, <code>nalgebra</code> and
<code>cgmath</code> may provide better tools.</p>
<h2 id="basic-usage"><a class="doc-anchor" href="#basic-usage">§</a>Basic usage</h2>
<p><a href="mat/struct.Mat.html" title="struct faer::mat::Mat"><code>Mat</code></a> is a resizable matrix type with dynamic capacity, which can be created using
<a href="mat/struct.Mat.html#method.new" title="associated function faer::mat::Mat::new"><code>Mat::new</code></a> to produce an empty $0\times 0$ matrix, <a href="mat/struct.Mat.html#method.zeros" title="associated function faer::mat::Mat::zeros"><code>Mat::zeros</code></a> to create a rectangular
matrix filled with zeros, <a href="mat/struct.Mat.html#method.identity" title="associated function faer::mat::Mat::identity"><code>Mat::identity</code></a> to create an identity matrix, or <a href="mat/struct.Mat.html#method.from_fn" title="associated function faer::mat::Mat::from_fn"><code>Mat::from_fn</code></a>
for the most generic case.</p>
<p>Given a <code>&amp;Mat&lt;E&gt;</code> (resp. <code>&amp;mut Mat&lt;E&gt;</code>), a <a href="mat/struct.MatRef.html" title="struct faer::mat::MatRef"><code>MatRef&lt;'_, E&gt;</code></a> (resp. <a href="mat/struct.MatMut.html" title="struct faer::mat::MatMut"><code>MatMut&lt;'_, E&gt;</code></a>) can be created by calling <a href="mat/struct.Mat.html#method.as_ref" title="method faer::mat::Mat::as_ref"><code>Mat::as_ref</code></a> (resp. <a href="mat/struct.Mat.html#method.as_mut" title="method faer::mat::Mat::as_mut"><code>Mat::as_mut</code></a>), which allow
for more flexibility than <code>Mat</code> in that they allow slicing (<a href="mat/struct.MatRef.html#method.get" title="method faer::mat::MatRef::get"><code>MatRef::get</code></a>) and splitting
(<a href="mat/struct.MatRef.html#method.split_at" title="method faer::mat::MatRef::split_at"><code>MatRef::split_at</code></a>).</p>
<p><code>MatRef</code> and <code>MatMut</code> are lightweight view objects. The former can be copied freely while the
latter has move and reborrow semantics, as described in its documentation.</p>
<p>More details about the vocabulary types can be found in each one’s module’s
documentation. See also: <a href="trait.Entity.html" title="trait faer::Entity"><code>faer_entity::Entity</code></a> and <a href="complex_native/index.html" title="mod faer::complex_native"><code>complex_native</code></a>.</p>
<p>Most of the matrix operations can be used through the corresponding math operators: <code>+</code> for
matrix addition, <code>-</code> for subtraction, <code>*</code> for either scalar or matrix multiplication depending
on the types of the operands.</p>
<h3 id="example"><a class="doc-anchor" href="#example">§</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>faer::{mat, scale, Mat};

<span class="kw">let </span>a = <span class="macro">mat!</span>[
    [<span class="number">1.0</span>, <span class="number">5.0</span>, <span class="number">9.0</span>],
    [<span class="number">2.0</span>, <span class="number">6.0</span>, <span class="number">10.0</span>],
    [<span class="number">3.0</span>, <span class="number">7.0</span>, <span class="number">11.0</span>],
    [<span class="number">4.0</span>, <span class="number">8.0</span>, <span class="number">12.0f64</span>],
];

<span class="kw">let </span>b = Mat::&lt;f64&gt;::from_fn(<span class="number">4</span>, <span class="number">3</span>, |i, j| (i + j) <span class="kw">as </span>f64);

<span class="kw">let </span>add = <span class="kw-2">&amp;</span>a + <span class="kw-2">&amp;</span>b;
<span class="kw">let </span>sub = <span class="kw-2">&amp;</span>a - <span class="kw-2">&amp;</span>b;
<span class="kw">let </span>scale = scale(<span class="number">3.0</span>) * <span class="kw-2">&amp;</span>a;
<span class="kw">let </span>mul = <span class="kw-2">&amp;</span>a * b.transpose();

<span class="kw">let </span>a00 = a[(<span class="number">0</span>, <span class="number">0</span>)];</code></pre></div>
<h2 id="matrix-decompositions"><a class="doc-anchor" href="#matrix-decompositions">§</a>Matrix decompositions</h2>
<p><code>faer</code> provides a variety of matrix factorizations, each with its own advantages and drawbacks:</p>
<h3 id="cholesky-decomposition"><a class="doc-anchor" href="#cholesky-decomposition">§</a>Cholesky decomposition</h3>
<p><a href="mat/struct.Mat.html#method.cholesky" title="method faer::mat::Mat::cholesky"><code>Mat::cholesky</code></a> decomposes a self-adjoint positive definite matrix $A$ such that
$$A = LL^H,$$
where $L$ is a lower triangular matrix. This decomposition is highly efficient and has good
stability properties.</p>
<p><a href="sparse/linalg/solvers/struct.Cholesky.html" title="struct faer::sparse::linalg::solvers::Cholesky">An implementation for sparse matrices is also available.</a></p>
<h3 id="bunch-kaufman-decomposition"><a class="doc-anchor" href="#bunch-kaufman-decomposition">§</a>Bunch-Kaufman decomposition</h3>
<p><a href="mat/struct.Mat.html#method.lblt" title="method faer::mat::Mat::lblt"><code>Mat::lblt</code></a> decomposes a self-adjoint (possibly indefinite) matrix $A$ such that
$$P A P^\top = LBL^H,$$
where $P$ is a permutation matrix, $L$ is a lower triangular matrix, and $B$ is a block
diagonal matrix, with $1 \times 1$ or $2 \times 2$ diagonal blocks.
This decomposition is efficient and has good stability properties.</p>
<h3 id="lu-decomposition-with-partial-pivoting"><a class="doc-anchor" href="#lu-decomposition-with-partial-pivoting">§</a>LU decomposition with partial pivoting</h3>
<p><a href="mat/struct.Mat.html#method.partial_piv_lu" title="method faer::mat::Mat::partial_piv_lu"><code>Mat::partial_piv_lu</code></a> decomposes a square invertible matrix $A$ into a lower triangular
matrix $L$, a unit upper triangular matrix $U$, and a permutation matrix $P$, such that
$$PA = LU.$$
It is used by default for computing the determinant, and is generally the recommended method
for solving a square linear system or computing the inverse of a matrix (although we generally
recommend using a <a href="linalg/solvers/trait.Solver.html" title="trait faer::linalg::solvers::Solver"><code>faer::linalg::solvers::Solver</code></a> instead of
computing the inverse explicitly).</p>
<p><a href="sparse/linalg/solvers/struct.Lu.html" title="struct faer::sparse::linalg::solvers::Lu">An implementation for sparse matrices is also available.</a></p>
<h3 id="lu-decomposition-with-full-pivoting"><a class="doc-anchor" href="#lu-decomposition-with-full-pivoting">§</a>LU decomposition with full pivoting</h3>
<p><a href="mat/struct.Mat.html#method.full_piv_lu" title="method faer::mat::Mat::full_piv_lu"><code>Mat::full_piv_lu</code></a> Decomposes a generic rectangular matrix $A$ into a lower triangular
matrix $L$, a unit upper triangular matrix $U$, and permutation matrices $P$ and $Q$, such that
$$PAQ^\top = LU.$$
It can be more stable than the LU decomposition with partial pivoting, in exchange for being
more computationally expensive.</p>
<h3 id="qr-decomposition"><a class="doc-anchor" href="#qr-decomposition">§</a>QR decomposition</h3>
<p>The QR decomposition (<a href="mat/struct.Mat.html#method.qr" title="method faer::mat::Mat::qr"><code>Mat::qr</code></a>) decomposes a matrix $A$ into the product
$$A = QR,$$
where $Q$ is a unitary matrix, and $R$ is an upper trapezoidal matrix. It is often used for
solving least squares problems.</p>
<p><a href="sparse/linalg/solvers/struct.Qr.html" title="struct faer::sparse::linalg::solvers::Qr">An implementation for sparse matrices is also available.</a></p>
<h3 id="qr-decomposition-with-column-pivoting"><a class="doc-anchor" href="#qr-decomposition-with-column-pivoting">§</a>QR decomposition with column pivoting</h3>
<p>The QR decomposition with column pivoting (<a href="mat/struct.Mat.html#method.col_piv_qr" title="method faer::mat::Mat::col_piv_qr"><code>Mat::col_piv_qr</code></a>) decomposes a matrix $A$ into
the product
$$AP^\top = QR,$$
where $P$ is a permutation matrix, $Q$ is a unitary matrix, and $R$ is an upper trapezoidal
matrix.</p>
<p>It is slower than the version with no pivoting, in exchange for being more numerically stable
for rank-deficient matrices.</p>
<h3 id="singular-value-decomposition"><a class="doc-anchor" href="#singular-value-decomposition">§</a>Singular value decomposition</h3>
<p>The SVD of a matrix $M$ of shape $(m, n)$ is a decomposition into three components $U$, $S$,
and $V$, such that:</p>
<ul>
<li>$U$ has shape $(m, m)$ and is a unitary matrix,</li>
<li>$V$ has shape $(n, n)$ and is a unitary matrix,</li>
<li>$S$ has shape $(m, n)$ and is zero everywhere except the main diagonal, with nonnegative
diagonal values in nonincreasing order,</li>
<li>and finally:</li>
</ul>
<p>$$M = U S V^H.$$</p>
<p>The SVD is provided in two forms: either the full matrices $U$ and $V$ are computed, using
<a href="mat/struct.Mat.html#method.svd" title="method faer::mat::Mat::svd"><code>Mat::svd</code></a>, or only their first $\min(m, n)$ columns are computed, using
<a href="mat/struct.Mat.html#method.thin_svd" title="method faer::mat::Mat::thin_svd"><code>Mat::thin_svd</code></a>.</p>
<p>If only the singular values (elements of $S$) are desired, they can be obtained in
nonincreasing order using <a href="mat/struct.Mat.html#method.singular_values" title="method faer::mat::Mat::singular_values"><code>Mat::singular_values</code></a>.</p>
<h3 id="eigendecomposition"><a class="doc-anchor" href="#eigendecomposition">§</a>Eigendecomposition</h3>
<p><strong>Note</strong>: The order of the eigenvalues is currently unspecified and may be changed in a future
release.</p>
<p>The eigendecomposition of a square matrix $M$ of shape $(n, n)$ is a decomposition into
two components $U$, $S$:</p>
<ul>
<li>$U$ has shape $(n, n)$ and is invertible,</li>
<li>$S$ has shape $(n, n)$ and is a diagonal matrix,</li>
<li>and finally:</li>
</ul>
<p>$$M = U S U^{-1}.$$</p>
<p>If $M$ is hermitian, then $U$ can be made unitary ($U^{-1} = U^H$), and $S$ is real valued.</p>
<p>Depending on the domain of the input matrix and whether it is self-adjoint, multiple methods
are provided to compute the eigendecomposition:</p>
<ul>
<li><a href="mat/struct.Mat.html#method.selfadjoint_eigendecomposition" title="method faer::mat::Mat::selfadjoint_eigendecomposition"><code>Mat::selfadjoint_eigendecomposition</code></a> can be used with either real or complex matrices,
producing an eigendecomposition of the same type.</li>
<li><a href="mat/struct.Mat.html#method.eigendecomposition" title="method faer::mat::Mat::eigendecomposition"><code>Mat::eigendecomposition</code></a> can be used with either real or complex matrices, but the output
complex type has to be specified.</li>
<li><a href="mat/struct.Mat.html#method.complex_eigendecomposition" title="method faer::mat::Mat::complex_eigendecomposition"><code>Mat::complex_eigendecomposition</code></a> can only be used with complex matrices, with the output
having the same type.</li>
</ul>
<p>If only the eigenvalues (elements of $S$) are desired, they can be obtained in
nonincreasing order using <a href="mat/struct.Mat.html#method.selfadjoint_eigenvalues" title="method faer::mat::Mat::selfadjoint_eigenvalues"><code>Mat::selfadjoint_eigenvalues</code></a>, <a href="mat/struct.Mat.html#method.eigenvalues" title="method faer::mat::Mat::eigenvalues"><code>Mat::eigenvalues</code></a>, or
<a href="mat/struct.Mat.html#method.complex_eigenvalues" title="method faer::mat::Mat::complex_eigenvalues"><code>Mat::complex_eigenvalues</code></a>, with the same conditions described above.</p>
<h2 id="crate-features"><a class="doc-anchor" href="#crate-features">§</a>Crate features</h2>
<ul>
<li><code>std</code>: enabled by default. Links with the standard library to enable additional features such
as cpu feature detection at runtime.</li>
<li><code>rayon</code>: enabled by default. Enables the <code>rayon</code> parallel backend and enables global
parallelism by default.</li>
<li><code>serde</code>: Enables serialization and deserialization of <a href="mat/struct.Mat.html" title="struct faer::mat::Mat"><code>Mat</code></a>.</li>
<li><code>npy</code>: Enables conversions to/from numpy’s matrix file format.</li>
<li><code>perf-warn</code>: Produces performance warnings when matrix operations are called with suboptimal
data layout.</li>
<li><code>nightly</code>: Requires the nightly compiler. Enables experimental SIMD features such as AVX512.</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Col"><code>pub use col::<a class="struct" href="col/struct.Col.html" title="struct faer::col::Col">Col</a>;</code></div></li><li><div class="item-name" id="reexport.ColMut"><code>pub use col::<a class="struct" href="col/struct.ColMut.html" title="struct faer::col::ColMut">ColMut</a>;</code></div></li><li><div class="item-name" id="reexport.ColRef"><code>pub use col::<a class="struct" href="col/struct.ColRef.html" title="struct faer::col::ColRef">ColRef</a>;</code></div></li><li><div class="item-name" id="reexport.Mat"><code>pub use mat::<a class="struct" href="mat/struct.Mat.html" title="struct faer::mat::Mat">Mat</a>;</code></div></li><li><div class="item-name" id="reexport.MatMut"><code>pub use mat::<a class="struct" href="mat/struct.MatMut.html" title="struct faer::mat::MatMut">MatMut</a>;</code></div></li><li><div class="item-name" id="reexport.MatRef"><code>pub use mat::<a class="struct" href="mat/struct.MatRef.html" title="struct faer::mat::MatRef">MatRef</a>;</code></div></li><li><div class="item-name" id="reexport.Row"><code>pub use row::<a class="struct" href="row/struct.Row.html" title="struct faer::row::Row">Row</a>;</code></div></li><li><div class="item-name" id="reexport.RowMut"><code>pub use row::<a class="struct" href="row/struct.RowMut.html" title="struct faer::row::RowMut">RowMut</a>;</code></div></li><li><div class="item-name" id="reexport.RowRef"><code>pub use row::<a class="struct" href="row/struct.RowRef.html" title="struct faer::row::RowRef">RowRef</a>;</code></div></li><li><div class="item-name" id="reexport.dyn_stack"><code>pub use <a class="mod" href="../dyn_stack/index.html" title="mod dyn_stack">dyn_stack</a>;</code></div></li><li><div class="item-name" id="reexport.reborrow"><code>pub use <a class="mod" href="../reborrow/index.html" title="mod reborrow">reborrow</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="col/index.html" title="mod faer::col">col</a></div><div class="desc docblock-short">Column vector type.</div></li><li><div class="item-name"><a class="mod" href="complex_native/index.html" title="mod faer::complex_native">complex_native</a></div><div class="desc docblock-short">Native complex floating point types whose real and imaginary parts are stored contiguously.</div></li><li><div class="item-name"><a class="mod" href="diag/index.html" title="mod faer::diag">diag</a></div><div class="desc docblock-short">Diagonal matrix type.</div></li><li><div class="item-name"><a class="mod" href="io/index.html" title="mod faer::io">io</a></div><div class="desc docblock-short">De-serialization from common matrix file formats.</div></li><li><div class="item-name"><a class="mod" href="iter/index.html" title="mod faer::iter">iter</a></div><div class="desc docblock-short">Iterators and related utilities.</div></li><li><div class="item-name"><a class="mod" href="linalg/index.html" title="mod faer::linalg">linalg</a></div><div class="desc docblock-short">Linear algebra module.</div></li><li><div class="item-name"><a class="mod" href="mat/index.html" title="mod faer::mat">mat</a></div><div class="desc docblock-short">Matrix type.</div></li><li><div class="item-name"><a class="mod" href="modules/index.html" title="mod faer::modules">modules</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Re-exports.</div></li><li><div class="item-name"><a class="mod" href="perm/index.html" title="mod faer::perm">perm</a></div><div class="desc docblock-short">Permutation matrices.</div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod faer::prelude">prelude</a></div><div class="desc docblock-short">faer prelude. Includes useful types and traits for solving linear systems.</div></li><li><div class="item-name"><a class="mod" href="row/index.html" title="mod faer::row">row</a></div><div class="desc docblock-short">Row vector type.</div></li><li><div class="item-name"><a class="mod" href="solvers/index.html" title="mod faer::solvers">solvers</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Matrix solvers and decompositions.</div></li><li><div class="item-name"><a class="mod" href="sparse/index.html" title="mod faer::sparse">sparse</a></div><div class="desc docblock-short">Sparse data structures and algorithms.
Sparse matrix data structures.</div></li><li><div class="item-name"><a class="mod" href="stats/index.html" title="mod faer::stats">stats</a></div><div class="desc docblock-short">Statistics-related utilities.</div></li><li><div class="item-name"><a class="mod" href="utils/index.html" title="mod faer::utils">utils</a></div><div class="desc docblock-short">Various utilities for low level implementations in generic code.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.assert_matrix_eq.html" title="macro faer::assert_matrix_eq">assert_matrix_eq</a></div><div class="desc docblock-short">Compare matrices for exact or approximate equality.</div></li><li><div class="item-name"><a class="macro" href="macro.col.html" title="macro faer::col">col</a></div><div class="desc docblock-short">Creates a <a href="col/struct.Col.html" title="struct faer::col::Col"><code>col::Col</code></a> containing the arguments.</div></li><li><div class="item-name"><a class="macro" href="macro.concat.html" title="macro faer::concat">concat</a></div><div class="desc docblock-short">Concatenates the matrices in each row horizontally,
then concatenates the results vertically.</div></li><li><div class="item-name"><a class="macro" href="macro.dbgf.html" title="macro faer::dbgf">dbgf</a></div><div class="desc docblock-short">Similar to the <a href="https://doc.rust-lang.org/1.80.1/std/macro.dbg.html" title="macro std::dbg"><code>dbg</code></a> macro, but takes a format spec as a first parameter.</div></li><li><div class="item-name"><a class="macro" href="macro.mat.html" title="macro faer::mat">mat</a></div><div class="desc docblock-short">Creates a <a href="mat/struct.Mat.html" title="struct faer::mat::Mat"><code>Mat</code></a> containing the arguments.</div></li><li><div class="item-name"><a class="macro" href="macro.row.html" title="macro faer::row">row</a></div><div class="desc docblock-short">Creates a <a href="row/struct.Row.html" title="struct faer::row::Row"><code>row::Row</code></a> containing the arguments.</div></li><li><div class="item-name"><a class="macro" href="macro.unzipped.html" title="macro faer::unzipped">unzipped</a></div><div class="desc docblock-short">Used to undo the zipping by the <a href="prelude/macro.zipped.html" title="macro faer::prelude::zipped"><code>zipped!</code></a> macro.</div></li><li><div class="item-name"><a class="macro" href="macro.zipped.html" title="macro faer::zipped">zipped</a></div><div class="desc docblock-short">Zips together matrix of the same size, so that coefficient-wise operations can be performed on
their elements.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Scale.html" title="struct faer::Scale">Scale</a></div><div class="desc docblock-short">Factor for matrix-scalar multiplication.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Conj.html" title="enum faer::Conj">Conj</a></div><div class="desc docblock-short">Whether a matrix should be implicitly conjugated when read or not.</div></li><li><div class="item-name"><a class="enum" href="enum.Parallelism.html" title="enum faer::Parallelism">Parallelism</a></div><div class="desc docblock-short">Parallelism strategy that can be passed to most of the routines in the library.</div></li><li><div class="item-name"><a class="enum" href="enum.Side.html" title="enum faer::Side">Side</a></div><div class="desc docblock-short">Specifies whether the triangular lower or upper part of a matrix should be accessed.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ComplexField.html" title="trait faer::ComplexField">ComplexField</a></div><div class="desc docblock-short">Unstable trait containing the operations that a number type needs to implement.</div></li><li><div class="item-name"><a class="trait" href="trait.Conjugate.html" title="trait faer::Conjugate">Conjugate</a></div><div class="desc docblock-short">Trait for types that may be implicitly conjugated.</div></li><li><div class="item-name"><a class="trait" href="trait.Entity.html" title="trait faer::Entity">Entity</a></div><div class="desc docblock-short">Unstable core trait for describing how a scalar value may be split up into individual
component.</div></li><li><div class="item-name"><a class="trait" href="trait.Index.html" title="trait faer::Index">Index</a></div><div class="desc docblock-short">Trait for unsigned integers that can be indexed with.</div></li><li><div class="item-name"><a class="trait" href="trait.RealField.html" title="trait faer::RealField">RealField</a></div><div class="desc docblock-short">Unstable trait containing the operations that a real number type needs to implement.</div></li><li><div class="item-name"><a class="trait" href="trait.SignedIndex.html" title="trait faer::SignedIndex">SignedIndex</a></div><div class="desc docblock-short">Trait for signed integers corresponding to the ones satisfying <a href="trait.Index.html" title="trait faer::Index"><code>Index</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.SimpleEntity.html" title="trait faer::SimpleEntity">SimpleEntity</a></div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.disable_global_parallelism.html" title="fn faer::disable_global_parallelism">disable_global_parallelism</a></div><div class="desc docblock-short">Causes functions that access global parallelism settings to panic.</div></li><li><div class="item-name"><a class="fn" href="fn.get_global_parallelism.html" title="fn faer::get_global_parallelism">get_global_parallelism</a></div><div class="desc docblock-short">Gets the global parallelism settings.</div></li><li><div class="item-name"><a class="fn" href="fn.scale.html" title="fn faer::scale">scale</a></div><div class="desc docblock-short">Returns a factor for matrix-scalar multiplication.</div></li><li><div class="item-name"><a class="fn" href="fn.set_global_parallelism.html" title="fn faer::set_global_parallelism">set_global_parallelism</a></div><div class="desc docblock-short">Sets the global parallelism settings.</div></li></ul></section></div></main></body></html>
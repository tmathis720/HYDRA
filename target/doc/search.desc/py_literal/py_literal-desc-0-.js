searchState.loadedDescShard("py_literal", 0, "This crate provides a type <code>Value</code> that represents a Python …\nPython boolean (<code>bool</code>).\nPython byte sequence (<code>bytes</code>). When parsing, backslash …\nPython complex number (<code>complex</code>). The Python <code>complex</code> type …\nPython dictionary (<code>dict</code>).\nThe literal contained an empty set.\nPython floating-point number (<code>float</code>). The representation …\nError formatting a Python literal.\nAn illegal escape sequence in a string or bytes literal.\nPython integer (<code>int</code>). Python integers have unlimited …\nAn error caused by the writer.\nPython list (<code>list</code>).\nPython <code>None</code>.\nAn error in a numeric cast. For example, this might occur …\nError parsing a Python literal.\nAn error parsing a float. This might happen if the …\nPython set (<code>set</code>).\nPython string (<code>str</code>). When parsing, backslash escapes are …\nA syntax error.\nPython tuple (<code>tuple</code>).\nPython literal.\nIf <code>self</code> is <code>Value::Boolean</code>, returns the associated data. …\nIf <code>self</code> is <code>Value::Bytes</code>, returns the associated bytes. …\nIf <code>self</code> is <code>Value::Complex</code>, returns the associated complex …\nIf <code>self</code> is <code>Value::Dict</code>, returns the associated data. …\nIf <code>self</code> is <code>Value::Float</code>, returns the associated float. …\nIf <code>self</code> is <code>Value::Integer</code>, returns the associated integer. …\nIf <code>self</code> is <code>Value::List</code>, returns the associated data. …\nIf <code>self</code> is <code>Value::Set</code>, returns the associated data. …\nIf <code>self</code> is <code>Value::String</code>, returns the associated string. …\nIf <code>self</code> is <code>Value::Tuple</code>, returns the associated data. …\nFormats the value as a Python literal.\nFormats the value as an ASCII string.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses a <code>Value</code> from a Python literal. The goal is for the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>self</code> is <code>Value::Boolean</code>. Returns <code>false</code> …\nReturns <code>true</code> if <code>self</code> is <code>Value::Bytes</code>. Returns <code>false</code> …\nReturns <code>true</code> if <code>self</code> is <code>Value::Complex</code>. Returns <code>false</code> …\nReturns <code>true</code> if <code>self</code> is <code>Value::Dict</code>. Returns <code>false</code> …\nReturns <code>true</code> if <code>self</code> is <code>Value::Float</code>. Returns <code>false</code> …\nReturns <code>true</code> if <code>self</code> is <code>Value::Integer</code>. Returns <code>false</code> …\nReturns <code>true</code> if <code>self</code> is <code>Value::List</code>. Returns <code>false</code> …\nReturns <code>true</code> if <code>self</code> is <code>Value::None</code>. Returns <code>false</code> …\nReturns <code>true</code> if <code>self</code> is <code>Value::Set</code>. Returns <code>false</code> …\nReturns <code>true</code> if <code>self</code> is <code>Value::String</code>. Returns <code>false</code> …\nReturns <code>true</code> if <code>self</code> is <code>Value::Tuple</code>. Returns <code>false</code> …\nWrites the value as ASCII.")
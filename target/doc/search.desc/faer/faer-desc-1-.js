searchState.loadedDescShard("faer", 1, "Returns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the number of columns of the matrix used to …\nReturns the number of rows of the matrix used to construct …\nSolves the equation <code>self * X = rhs</code> when self is square, …\nSolves the equation <code>conjugate(self) * X = rhs</code> when self is …\nSolves the equation <code>conjugate(self) * X = rhs</code> when self is …\nSolves the equation <code>adjoint(self) * X = rhs</code> when self is …\nSolves the equation <code>adjoint(self) * X = rhs</code> when self is …\nSolves the equation <code>self * X = rhs</code> when self is square, …\nSolves the equation <code>self * X = rhs</code>, and returns the result.\nSolves the equation <code>conjugate(self) * X = rhs</code>, and returns …\nSolves the equation <code>conjugate(self) * X = rhs</code>, in the …\nSolves the equation <code>self * X = rhs</code>, in the sense of least …\nSolves the equation <code>transpose(self) * X = rhs</code> when self is …\nSolves the equation <code>transpose(self) * X = rhs</code> when self is …\nReturns the symbolic Cholesky factorization of the input …\nReturns the symbolic QR factorization of the input matrix.\nReturns the symbolic LU factorization of the input matrix.\nReturns the Cholesky factorization of the input matrix …\nReturns the QR factorization of the input matrix with the …\nReturns the LU factorization of the input matrix with the …\nAssuming <code>self</code> is a lower triangular matrix, solves the …\nAssuming <code>self</code> is a lower triangular matrix, solves the …\nAssuming <code>self</code> is a unit lower triangular matrix, solves …\nAssuming <code>self</code> is a unit lower triangular matrix, solves …\nAssuming <code>self</code> is a unit upper triangular matrix, solves …\nAssuming <code>self</code> is a unit upper triangular matrix, solves …\nAssuming <code>self</code> is an upper triangular matrix, solves the …\nAssuming <code>self</code> is an upper triangular matrix, solves the …\nReturns the sum of <code>lhs</code> and <code>rhs</code>.\nComputes the sum of <code>dst</code> and <code>src</code> and stores the result in …\nComputes the sum of <code>lhs</code> and <code>rhs</code>, storing the result in <code>dst</code> …\nReturns the resulting matrix obtained by applying <code>f</code> to the …\nReturns the resulting matrix obtained by applying <code>f</code> to the …\nReturns the difference of <code>lhs</code> and <code>rhs</code>.\nComputes the difference of <code>dst</code> and <code>src</code> and stores the …\nComputes the difference of <code>lhs</code> and <code>rhs</code>, storing the result …\nReturns the resulting matrix obtained by applying <code>f</code> to the …\nReturns the sparsity pattern containing the union of those …\nComputes the adjoint of the matrix <code>A</code> and returns a view …\nComputes the adjoint of the symbolic matrix <code>A</code> and returns …\nComputes the self-adjoint permutation $P A P^\\top$ of the …\nComputes the size and alignment of the workspace required …\nSorts and deduplicates <code>row_indices</code> and <code>values</code> …\nSorts <code>row_indices</code> and <code>values</code> simultaneously so that …\nComputes the transpose of the matrix <code>A</code> and returns a view …\nNaNs are skipped, and they’re not included in the total …\nSpecifies how missing values should be handled in mean and …\nThe normal distribution, <code>N(mean, std_dev**2)</code>.\nThe normal distribution, <code>N(mean, std_dev**2)</code> for …\nThe normal distribution, <code>N(mean, std_dev**2)</code> for …\nThe normal distribution, <code>N(mean, std_dev**2)</code> for …\nNaNs are passed as-is to arithmetic operators.\nThe standard distribution. Samples uniformly distributed …\nThe standard distribution. Samples uniformly distributed …\nThe standard normal distribution, <code>N(0, 1)</code> for …\nThe standard normal distribution, <code>N(0, 1)</code> for …\nThe standard normal distribution, <code>N(0, 1)</code> for …\nThe standard distribution. Samples uniformly distributed …\nUniformly samples a unitary matrix from the unitary group, …\nComputes the mean of the columns of <code>mat</code> and stores the …\nComputes the variance of the columns of <code>mat</code> given their …\nDimension of the sampled matrix.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct, from dimensions, mean and coefficient of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNumber of columns of the sampled matrix.\nNumber of columns of the sampled matrix.\nNumber of columns of the sampled matrix.\nNumber of columns of the sampled row.\nNumber of columns of the sampled row.\nNumber of columns of the sampled row.\nConstruct, from dimensions, mean and standard deviation.\nNormal distribution parameters for a single scalar.\nNormal distribution parameters for a single scalar.\nNormal distribution parameters for a single scalar.\nNumber of rows of the sampled matrix.\nNumber of rows of the sampled matrix.\nNumber of rows of the sampled matrix.\nNumber of rows of the sampled column.\nNumber of rows of the sampled column.\nNumber of rows of the sampled column.\nComputes the mean of the rows of <code>mat</code> and stores the result …\nComputes the variance of the rows of <code>mat</code> given their mean, …\nIndex and matrix types with compile time checks, whichh …\nSimd operations for a specific type satisfying <code>ComplexField</code>…\nSlice types for entities.\nUtilities relating to threading and parallelism.\nVector type for entities.\nArray of length equal to the value tied to <code>&#39;n</code>.\nImmutable array group of length equal to the value tied to …\nMutable array group of length equal to the value tied to <code>&#39;n</code>…\n<code>I</code> value smaller than the size corresponding to the …\n<code>I</code> value smaller or equal to the size corresponding to the …\n<code>I</code> value smaller than the size corresponding to the …\n<code>usize</code> value tied to the lifetime <code>&#39;n</code>.\nReturns the unconstrained slice.\nReturns the unconstrained slice.\nConvert a constrained slice to an unconstrained one.\nCheck that the index is bounded by <code>self</code>, or panic …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns an index value.\nReturns a constrained array after checking that its length …\nReturns a constrained array after checking that its length …\nAssert that the values of <code>slice</code> are all bounded by <code>size</code>.\nAssert that the values of <code>slice</code> are all bounded by <code>size</code>.\nAssume that the values of <code>slice</code> are all bounded by the …\nAssume that the values of <code>slice</code> are all bounded by the …\nAssert that the values of <code>slice</code> are all bounded by <code>size</code>.\nAssert that the values of <code>slice</code> are all bounded by <code>size</code>.\nAssume that the values of <code>slice</code> are all bounded by the …\nAssume that the values of <code>slice</code> are all bounded by the …\nReturns the index if available, or <code>None</code> otherwise.\nReturns an iterator of the indices smaller than <code>self</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the unconstrained value.\nReturns the unconstrained value.\nReturns the unconstrained value.\nReturns the inner value.\nReturns the unconstrained slice.\nReturns the unconstrained slice.\nReturns the length of <code>self</code>.\nDense matrices with compile-time access checks.\nReturns an array group with length after checking that its …\nReturns an array group with length after checking that its …\nReturns a new index after asserting that it’s bounded by …\nReturns a constrained inclusive index after checking that …\nReturns a constrained index value if <code>idx</code> is nonnegative, …\nCreate a new <code>Size</code> tied to the lifetime <code>&#39;n</code>.\nReturns a new index without asserting that it’s bounded …\nReturns a constrained inclusive index, assuming that it’…\nReturns a constrained index value if <code>idx</code> is nonnegative, …\nReturns a new index without asserting that it’s bounded …\nReturns a constrained inclusive index, assuming that it’…\nReturns a constrained index value if <code>idx</code> is nonnegative, …\nReturns the next index, bounded inclusively by the value …\nReturns a <code>None</code> value.\nPermutations with compile-time checks.\nReturns an iterator over constrained indices from <code>0</code> to <code>self</code>…\nRead the element at position <code>j</code>.\nRead the element at position <code>j</code>.\nSparse matrices with compile-time access checks.\nReturns a subslice at from the range start to its end.\nReturns a subslice at from the range start to its end.\nUnimplemented: Sign extend the value.\nUnimplemented: Sign extend the value.\nSign extend the value.\nReturns the index, bounded inclusively by the value tied …\nTruncate <code>self</code> to a smaller type <code>I</code>.\nCheck that the index is bounded by <code>self</code>, or return <code>None</code> …\nCreate a new <code>Size</code> with a lifetime tied to <code>n</code>.\nCreate two new <code>Size</code> with lifetimes tied to <code>m</code> and <code>n</code>.\nWrite <code>value</code> to the location at position <code>j</code>.\nZero extend the value.\nUnimplemented: Zero extend the value.\nUnimplemented: Zero extend the value.\nMutable dense matrix view with dimensions equal to the …\nImmutable dense matrix view with dimensions equal to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the unconstrained matrix.\nReturns the unconstrained matrix.\nReturns the number of columns of the matrix.\nReturns the number of columns of the matrix.\nReturns a new matrix view after checking that its …\nReturns a new matrix view after checking that its …\nReturns the number of rows of the matrix.\nReturns the number of rows of the matrix.\nReturns the element at position <code>(i, j)</code>.\nReturns the element at position <code>(i, j)</code>.\nWrites <code>value</code> to the location at position <code>(i, j)</code>.\nPermutation of length equal to the value tied to <code>&#39;n</code>.\nReturns the forward and inverse permutation indices.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the unconstrained permutation.\nReturns the inverse permutation.\nReturns the length of the permutation.\nReturns a new permutation after checking that it matches …\nMutable sparse matrix view with dimensions equal to the …\nImmutable sparse matrix view with dimensions equal to the …\nSymbolic structure view with dimensions equal to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the unconstrained symbolic structure.\nReturns the unconstrained matrix.\nReturns the unconstrained matrix.\nReturns the number of columns of the matrix.\nReturns a new symbolic structure after checking that its …\nReturns a new matrix view after checking that its …\nReturns a new matrix view after checking that its …\nReturns the number of rows of the matrix.\nReturns the row indices in column <code>j</code>.\nReturns the row indices in column <code>j</code>.\nReturns the symbolic structure of the matrix.\nReturns the symbolic structure of the matrix.\nReturns the values in column <code>j</code>.\nReturns the values in column <code>j</code>.\nThe corresponding <code>Conj</code> value.\nSimilar to <code>Conj</code>, but determined at compile time instead of …\nThe opposing conjugation type.\nDo not conjugate.\nSimd prefix, contains the elements before the body.\nSimd prefix (mutable), contains the elements before the …\nWrapper for simd operations for type <code>E</code>.\nSimd suffix, contains the elements after the body.\nSimd suffix (mutable), contains the elements after the …\nDo conjugate.\nReturns <code>abs(values)</code>.\nReturns <code>abs(values) * abs(values)</code>.\nReturns <code>abs(values) * abs(values) + acc</code>.\nReturns <code>lhs + rhs</code>.\nComputes the alignment offset for subsequent aligned loads.\nComputes the alignment offset for subsequent aligned loads …\nConvert a slice to a partial register prefix and suffix, …\nConvert a mutable slice to a partial register prefix and …\nConvert a slice to a slice over vector registers, and a …\nConvert a mutable slice to a slice over vector registers, …\nReturns <code>op(lhs) * rhs</code>, where <code>op</code> is either the conjugation …\nReturns <code>op(lhs) * rhs + acc</code>, where <code>op</code> is either the …\nReturns <code>conj(lhs) * rhs</code>.\nReturns <code>conj(lhs) * rhs + acc</code>.\nReturns an instance of the corresponding conjugation type.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>a &gt; b</code>.\nReturns <code>a &gt;= b</code>.\nReturns <code>a + b</code>.\nReturns <code>if mask { if_true } else { if_false }</code>\nReturns <code>[0, 1, 2, 3, ..., REGISTER_SIZE - 1]</code>\nFill all the register lanes with the same value.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>a &lt; b</code>.\nReturns <code>a &lt;= b</code>.\nReturns <code>lhs * rhs</code>.\nReturns <code>lhs * rhs + acc</code>.\nReturns <code>-a</code>.\nCreate a new wrapper from a simd token.\nSum the components of a vector register into a single …\nRotate <code>values</code> to the left, with overflowing entries …\nReturns an estimate of <code>op(lhs) * rhs</code>, where <code>op</code> is either …\nReturns an estimate of <code>op(lhs) * rhs + acc</code>, where <code>op</code> is …\nReturns <code>conj(lhs) * rhs</code>.\nReturns an estimate of <code>conj(lhs) * rhs + acc</code>.\nReturns <code>lhs * rhs</code>.\nReturns an estimate of <code>lhs * rhs + acc</code>.\nReturns <code>lhs * rhs</code>.\nReturns <code>abs(values)</code> or <code>abs(values) * abs(values)</code>, …\nReturns <code>if mask { if_true } else { if_false }</code>\nSimd token.\nFill all the register lanes with the same value.\nReturns <code>lhs - rhs</code>.\nWrapper around a group of references.\nWrapper around a group of mutable references.\nAnalogous to an immutable reference to a slice for groups.\nAnalogous to a mutable reference to a slice for groups.\nDecompose <code>self</code> into a slice of arrays of size <code>N</code>, and a …\nDecompose <code>self</code> into a mutable slice of arrays of size <code>N</code>, …\nFill the slice with zeros.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCopies and returns the value pointed to by the references.\nCopies and returns the value pointed to by the references.\nGet a <code>RefGroup</code> pointing to the element at position <code>idx</code>.\nGet a <code>RefGroup</code> pointing to the element at position <code>idx</code>.\nGet a <code>RefGroupMut</code> pointing to the element at position <code>idx</code>.\nGet a <code>RefGroup</code> pointing to the element at position <code>idx</code>, …\nGet a <code>RefGroup</code> pointing to the element at position <code>idx</code>, …\nGet a <code>RefGroupMut</code> pointing to the element at position <code>idx</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator of slices over chunks of size …\nReturns an iterator of slices over chunks of size …\nConsume <code>self</code> to return the internally stored group of …\nConsume <code>self</code> to return the internally stored group of …\nConsume <code>self</code> to return the internally stored group of …\nConsume <code>self</code> to return the internally stored group of …\nReturns an iterator of <code>RefGroupMut</code> over the elements of …\nReturns an iterator of <code>RefGroup</code> over the elements of the …\nChecks whether the slice is empty.\nChecks whether the slice is empty.\nReturns the length of the slice.\nReturns the length of the slice.\nCreate a new <code>RefGroup</code> from a group of references.\nCreate a new <code>RefGroupMut</code> from a group of mutable …\nCreate a new <code>SliceGroup</code> from a group of slice references.\nCreate a new <code>SliceGroup</code> from a group of mutable slice …\nRead the element pointed to by the references.\nRead the element pointed to by the references.\nRead the element at position <code>idx</code>.\nRead the element at position <code>idx</code>.\nRead the element at position <code>idx</code>, without bound checks.\nRead the element at position <code>idx</code>, without bound checks.\nWrites <code>value</code> to the location pointed to by the references.\nWrites <code>value</code> to the location pointed to by the references.\nSplit <code>self</code> at the midpoint <code>idx</code>, and return the two parts.\nSplit <code>self</code> at the midpoint <code>idx</code>, and return the two parts.\nReturns the subslice of <code>self</code> from the start to the end of …\nReturns the subslice of <code>self</code> from the start to the end of …\nReturns the subslice of <code>self</code> from the start to the end of …\nReturns the subslice of <code>self</code> from the start to the end of …\nConvert a reference to an array to an array of references.\nConvert a mutable reference to an array to an array of …\nWrite <code>value</code> to the location pointed to by the references.\nWrite <code>value</code> to the location at position <code>idx</code>.\nWrite <code>value</code> to the location at position <code>idx</code>, without bound …\nUnsafe <code>Send</code> and <code>Sync</code> pointer type.\nExecutes the tasks by passing the values in <code>0..n_tasks</code> to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nExecutes the two operations, possibly in parallel, while …\nReturns the start and length of a subsegment of <code>0..n</code>, …\nThe amount of threads that should ideally execute an …\nAnalogous to <code>alloc::vec::Vec</code> for groups.\nReturn a mutable reference to the inner group of …\nReturn a reference to the inner group of <code>alloc::vec::Vec</code>.\nReturn a <code>SliceGroup</code> view over the elements of <code>self</code>.\nReturn a <code>SliceGroupMut</code> mutable view over the elements of …\nReturns the capacity of the vector group.\nClear the vector, making it empty.\nReturns the argument unchanged.\nCreate a new <code>VecGroup</code> from a group of <code>alloc::vec::Vec</code>.\nCalls <code>U::from(self)</code>.\nConsume <code>self</code> to return a group of <code>alloc::vec::Vec</code>.\nReturns the length of the vector group.\nCreate an empty <code>VecGroup</code>.\nRemove a new element from the end of <code>self</code>, and return it.\nPush a new element to the end of <code>self</code>.\nRemove a new element from position <code>index</code>, and return it.\nReserve enough capacity for extra <code>additional</code> elements.\nReserve exactly enough capacity for extra <code>additional</code> …\nResize the vector to <code>new_len</code>, filling the new elements with\nResize the vector to <code>new_len</code>, filling the new elements with\nTruncate the length of the vector to <code>len</code>.\nTry to reserve enough capacity for extra <code>additional</code> …\nTry to reserve exactly enough capacity for extra <code>additional</code>…")